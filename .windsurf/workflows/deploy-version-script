---
description: Automated script for deploying new versions
---

#!/bin/bash

# Automated Version Deployment Script
# This script automates the deployment of new versions following DevOps.click standards

set -eo pipefail

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    echo -e "${GREEN}[INFO]${NC} $1"
}

print_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

print_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

print_header() {
    echo -e "${BLUE}=== $1 ===${NC}"
}

# Function to check if we're in a git repo
check_git_repo() {
    if ! git rev-parse --git-dir > /dev/null 2>&1; then
        print_error "Not in a git repository"
        exit 1
    fi
}

# Function to check for uncommitted changes
check_uncommitted_changes() {
    if [[ -n $(git status --porcelain) ]]; then
        print_warning "You have uncommitted changes:"
        git status --short
        read -p "Do you want to continue? (y/N): " -n 1 -r
        echo
        if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            print_error "Aborting due to uncommitted changes"
            exit 1
        fi
    fi
}

# Function to get current version
get_current_version() {
    if [[ -f ".devops/.version" ]]; then
        cat ".devops/.version"
    else
        print_error "Version file .devops/.version not found"
        exit 1
    fi
}

# Function to increment version
increment_version() {
    local current_version="$1"
    local version_type="${2:-patch}"
    
    IFS='.' read -ra VERSION_PARTS <<< "$current_version"
    
    case "$version_type" in
        "major")
            VERSION_PARTS[0]=$((${VERSION_PARTS[0]} + 1))
            VERSION_PARTS[1]=0
            VERSION_PARTS[2]=0
            ;;
        "minor")
            VERSION_PARTS[1]=$((${VERSION_PARTS[1]} + 1))
            VERSION_PARTS[2]=0
            ;;
        "patch"|*)
            VERSION_PARTS[2]=$((${VERSION_PARTS[2]} + 1))
            ;;
    esac
    
    echo "${VERSION_PARTS[0]}.${VERSION_PARTS[1]}.${VERSION_PARTS[2]}"
}

# Function to find modified module files
find_modified_modules() {
    local modified_files
    modified_files=$(git diff --name-only HEAD~1 2>/dev/null || git diff --name-only)
    
    local module_files=()
    while IFS= read -r file; do
        if [[ -f "$file" ]] && grep -q "DOCLI_MODULE_VERSION" "$file" 2>/dev/null; then
            module_files+=("$file")
        fi
    done <<< "$modified_files"
    
    printf '%s\n' "${module_files[@]}"
}

# Function to update module version
update_module_version() {
    local file="$1"
    local new_version="$2"
    
    print_status "Updating module version in $file to $new_version"
    sed -i.bak "s/DOCLI_MODULE_VERSION=\"[^\"]*\"/DOCLI_MODULE_VERSION=\"$new_version\"/" "$file"
    rm -f "$file.bak"
}

# Function to update changelog
update_changelog() {
    local new_version="$1"
    local current_date=$(date +%Y-%m-%d)
    
    print_status "Updating CHANGELOG.md"
    
    # Create temporary changelog entry
    local temp_entry="

## [$new_version] - $current_date
### Added
- [Describe new features added]

### Changed
- [Describe changes made]

### Fixed
- [Describe bugs fixed]

### Improved
- [Describe improvements made]

"
    
    # Find the line after the latest version (after [Unreleased] section)
    if grep -q "## \[0\.0\." CHANGELOG.md; then
        # Insert after the unreleased section
        sed -i.bak "/^## \[Unreleased\]/a\\$temp_entry" CHANGELOG.md
    else
        # If no versions exist, add after unreleased
        sed -i.bak "/^## \[Unreleased\]/a\\$temp_entry" CHANGELOG.md
    fi
    
    rm -f CHANGELOG.md.bak
    print_warning "Please edit CHANGELOG.md to add actual changes before committing"
}

# Function to create commit
create_commit() {
    local new_version="$1"
    local current_date=$(date +%Y-%m-%d)
    
    print_status "Creating commit for version $new_version"
    
    # Stage files
    git add .devops/.version
    git add CHANGELOG.md
    
    # Add modified module files
    local modified_modules
    modified_modules=$(find_modified_modules)
    while IFS= read -r module; do
        if [[ -n "$module" ]]; then
            git add "$module"
        fi
    done <<< "$modified_modules"
    
    # Create commit
    git commit -m "release/$new_version

## [$new_version] - $current_date
### Added
- Enhanced Slack notification functions with full API support:
  - Added \`notify_slack()\` function with comprehensive Slack API capabilities
  - Added \`notify_slack_upload()\` for file uploads to Slack
  - Added \`notify_slack_rich()\` for rich messages with blocks
  - Maintained \`notify_slack_api()\` for backward compatibility
  - Support for threads, broadcasts, custom blocks, and webhook fallback
  - Flexible parameter system with environment variable defaults"
}

# Main execution
main() {
    print_header "DevOps.click Version Deployment"
    
    # Check prerequisites
    check_git_repo
    check_uncommitted_changes
    
    # Get current version
    local current_version
    current_version=$(get_current_version)
    print_status "Current version: $current_version"
    
    # Ask for version type
    echo "Select version increment type:"
    echo "1) patch (0.0.X)"
    echo "2) minor (0.X.0)"
    echo "3) major (X.0.0)"
    read -p "Choose [1-3]: " -n 1 -r
    echo
    
    local version_type="patch"
    case $REPLY in
        2) version_type="minor" ;;
        3) version_type="major" ;;
        *) version_type="patch" ;;
    esac
    
    # Calculate new version
    local new_version
    new_version=$(increment_version "$current_version" "$version_type")
    print_status "New version will be: $new_version"
    
    # Confirm
    read -p "Continue with version $new_version? (y/N): " -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]; then
        print_error "Aborted by user"
        exit 1
    fi
    
    # Update main version
    print_status "Updating main version file"
    echo "$new_version" > .devops/.version
    
    # Update module versions
    local modified_modules
    modified_modules=$(find_modified_modules)
    
    if [[ -n "$modified_modules" ]]; then
        print_status "Found modified module files:"
        echo "$modified_modules"
        
        read -p "Update module versions to 0.0.01? (y/N): " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            while IFS= read -r module; do
                if [[ -n "$module" ]]; then
                    update_module_version "$module" "0.0.01"
                fi
            done <<< "$modified_modules"
        fi
    else
        print_status "No modified module files found"
    fi
    
    # Update changelog
    update_changelog "$new_version"
    
    # Show what will be committed
    print_header "Files to be committed:"
    git status --short
    
    # Ask for final confirmation
    read -p "Create commit now? (y/N): " -n 1 -r
    echo
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        create_commit "$new_version"
        print_status "Commit created successfully!"
        
        # Show commit details
        print_header "Commit Details:"
        git log --oneline -1
        git show --name-only HEAD
        
        print_header "Next Steps:"
        echo "1. Review and edit CHANGELOG.md if needed"
        echo "2. Test your changes"
        echo "3. Push when ready: git push origin main"
        echo "4. Create tag: git tag -a \"v$new_version\" -m \"Release version $new_version\""
    else
        print_warning "Commit not created. Files are staged but not committed."
        print_status "Run 'git commit' when ready to commit the changes."
    fi
}

# Run main function
main "$@"
